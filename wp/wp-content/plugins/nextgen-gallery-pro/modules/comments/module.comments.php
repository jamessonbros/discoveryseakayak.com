<?php
/*
{
    Module: photocrati-comments,
    Depends: { photocrati-ajax, photocrati-datamapper }
}
*/
class M_Photocrati_Comments extends C_Base_Module
{
    protected $_interrupt_comment_post_redirection = FALSE;

    function define($context=FALSE)
    {
        parent::define(
            'photocrati-comments',
            'Comments',
            'AJAX operations for retrieving and creating comments on arbitrary items',
            '0.3',
            'http://www.photocrati.com',
            'Photocrati Media',
            'http://www.photocrati.com',
            $context
        );
    }

    function get_type_list()
    {
        return array(
            'A_Comment_Factory' => 'adapter.comment_factory.php',
            'A_Comment_Controller' => 'adapter.comment_controller.php',
            'C_Comment_Mapper' => 'class.comment_mapper.php',
            'C_Comment_Container' => 'class.comment_container.php',
            'I_Comment_Mapper' => 'interface.comment_mapper.php'
        );
    }

    function _register_hooks()
    {
        add_action('init',                  array(&$this, 'register_post_type'));
        add_action('pre_comment_on_post',   array(&$this, 'pre_comment_on_post'));

        add_filter('comment_post_redirect', array(&$this, 'comment_post_redirect'), 10, 2);
        add_filter('widget_comments_args',  array(&$this, 'widget_comments_args'));
    }

    function _register_adapters()
    {
        $this->get_registry()->add_adapter('I_Component_Factory', 'A_Comment_Factory');
        $this->get_registry()->add_adapter('I_Ajax_Controller', 'A_Comment_Controller');
    }

    function _register_utilities()
    {
        $this->get_registry()->add_utility('I_Comment_Mapper', 'C_Comment_Mapper');
    }

    function register_post_type()
    {
        register_post_type(
            'photocrati-comments',
            array(
                'labels' => array(
                    'name' => __('Comments'),
                    'singular_name' => __('Comment')
                ),
                'supports' => array(
                    'comments' => TRUE
                )
            )
        );
    }

    function pre_comment_on_post($post_id)
    {
        $post = get_post($post_id);
        if ($post->post_type == 'photocrati-comments' && !defined('DOING_AJAX' ))
        {
            $this->_interrupt_comment_post_redirection = TRUE;
            define('DOING_AJAX', TRUE);
        }
    }

    /**
     * The last action wp-comments-post.php before redirecting is to call the set_comment_post_redirect filter. To
     * prevent the WP 302 HTTP response we output our own json here and end execution. This should ONLY be done if
     * the pre_comment_on_post action (see above) has determined the comment belongs to one of our wrapper posts!
     *
     * @param $location
     * @throws E_Clean_Exit
     */
    function comment_post_redirect($location, $comment)
    {
        if ($this->_interrupt_comment_post_redirection)
        {
            // use this to track which comments we created
            add_comment_meta($comment->comment_ID, 'generated_by', 'photocrati-comments');

            if (isset($_REQUEST['nextgen_generated_comment']) && $_REQUEST['nextgen_generated_comment'] == 'true')
            {
                echo json_encode(array('success' => TRUE));
                throw new E_Clean_Exit();
            }
        }

        return $location;
    }

    /**
     * Applies a filter to widget_comments_args that prevents comments generated by this module from appearing in
     * the "Recent Comments" widget provided by Wordpress
     *
     * @param array $args
     * @return array $args
     */
    function widget_comments_args($args = array())
    {
        if (empty($args['meta_query']) || !is_array($args['meta_query']))
            $args['meta_query'] = array();

        $args['meta_query'][] = array(
            'key'     => 'generated_by',
            'value'   => 'photocrati-comments',
            'compare' => '!='
        );

        return $args;
    }
}

new M_Photocrati_Comments;
